---
title: "Introduction to R"
author: "For analysis of ABS data"
date: "15/01/2019"
output:
  html_document:
    toc: true
    toc_float: true
    rmarkdown::html_document:
    theme: journal
    fig_caption: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)

```

# Reading this document

This document was created in `R` using `Rmarkdown`. `Rmarkdown` allows for headers, text, lists, etc, alongside analysis and presentation data. It can then be output to `html` or `pdf`. It's neat!

In this document, text, like this, looks like this. 

**Code chunks** that you can copy-and-paste into your script is in a box with a light-grey background. 

The **output** from that code will be displayed underneath in a box with a white background. The numbers in square brackets e.g. `[1]` in the ouput mean only the line of the output, and hold no real meaning.

```{r hello}
# this is a chunk of code you can run (but this line is a comment that doesn't do anything)

2 + 3

ten <- 10
ten * 16

hello <- "hello"
paste0(hello, " Federica")

vector <- c(10, 20, 42)
vector * 2

```


# Setting up your project

A quick guide to setting up a project:

* Create a folder called `vet_participation`.
* In that folder, create subfolders called:
    - `data` to store your data;
    - `atlas` to store your graphics; and
    - `output` to store your other output (regression results, etc).
* Open `R Studio` and create a new project `File/New project...` -> `Existing directory` -> (find your new folder) -> `Create project`. 

When you open `vet_participation.Rproj`, your working directory will be set to the `vet_participation` folder on your computer. _Importantly_, when someone else opens `vet_participation.Rproj` it will set the working directory to the `vet_participation` folder on _their_ computer. This means analysis done on one computer will work one someone else's with minimal switching costs.



# Packages

'Packages' are a collection of functions with---_usually_---clear documentation. The people who make them are great and should feel good about themselves. Like any application, you need to _install_ packages and then open them when you want to use it. In `R`, we install (once only) using `install.packages("thePackageName")`:

```{r install packages, eval = FALSE}
install.packages("tidyverse")
install.packages("zoo")
```

(Note that tidyverse is a collection of packages rather than a single package itself).

We then load packages each time we start a new `R` session with `library(thePackageName)`:

```{r load packages}
library(tidyverse)
library(zoo)
```


# Reading messy data

We will jump right into it by reading an ABS dataset generated by 2016 Census TableBuilder. The file is called `vet_participation.csv`. Read it into `R` using the `read_csv` function:

```{r read data}
vet_participation <- read_csv("data/vet_participation.csv")

head(vet_participation)

```

Using the `head` function above, we see that there is one variable (column) in our dataset. This doesn't look right. There is, annoyingly, a 10 rows of _cruft_ included by the ABS at the top of the csv file (although this number will **vary**). We can skip the first 10 rows by using the `skip` argument:

```{r read data2}
vet_participation <- read_csv("data/vet_participation.csv",
                              skip = 10)

head(vet_participation)

```

Fixed at the top. Use `View(vet_participation)` to check the bottom of the dataset and see that there is also cruft there. We see that rows with `NA` values for X6 are rubbish, so we can filter them out using `filter` combined with `is.na(x)`, which returns a logical if `x` is `NA`, combined with the negator operator `!` (can be read as 'not', turning `TRUE` to `FALSE` and vice-versa). The filter portion of the chunk below reads 'keep all rows in which `X6` is **not** `NA`'.

```{r read data3}

old_number_rows <- nrow(vet_participation)

vet_participation <- read_csv("data/vet_participation.csv",
                              skip = 10) %>% 
                     filter(!is.na(X6))

new_number_rows <- nrow(vet_participation)

old_number_rows - new_number_rows

head(vet_participation)

```

Great. We dropped `r old_number_rows - new_number_rows` unnecessary rows at the bottom. 

`head` shows us that the values for the variables aren't filled in all the way down. We get a bunch of `NA`s instead. The very handy `zoo::na.locf` function can come to the rescue here (the notation there is `package::function`, and can be used in your code to explicitly call a function from a particular package. This is sometimes needed if there is more than one function with the same name). We can ask for more details about a function---what it does; what its arguments and output are; some examples---with `?na.locf`.


```{r read data4}
vet_participation <- read_csv("data/vet_participation.csv",
                              skip = 10)  %>% 
                     filter(!is.na(X6)) %>% 
                     na.locf()

head(vet_participation)

```


Fixed! 

## Renaming and data coding

Now we should manipulate the dataset to create clear, no-space variable names using `rename`. First use `names` to produce a vector of current variable names in the dataset. Then use `rename` to rename the variables.

```{r rename}
names(vet_participation)

vet_participation <- vet_participation %>% 
                     rename(
                       age = "AGE5P - Age in Five Year Groups",
                       sex = "SEXP Sex",
                       institution = "TYPP Type of Educational Institution Attending",
                       irsad_dec = "IRSAD Deciles at SA1 Level (Area)",
                       rural = "RA (UR)",
                       n = X6
                     )

names(vet_participation)

```

Now we want to look at how things are coded. We can use the `unique` function to retrieve all unique values of a given vector combined with the `pull` function to pull a vector out of the dataset. The first line here reads 'define `age_unique` as all `unique` values in the `age` vector pulled from the `vet_participation` dataset. When we define a variable there is no output, so we call the variable on the next line to show the results. Alternatively, this can be done automatically by surrounding the whole line in brackets:

```{r unique}
age_unique <- vet_participation %>% pull(age) %>% unique()
age_unique

(sex_unique <- vet_participation %>% pull(sex) %>% unique())

(institution_unique <- vet_participation %>% pull(institution) %>% unique())

(irsad_dec_unique <- vet_participation %>% pull(irsad_dec) %>% unique())

(rural_unique <- vet_participation %>% pull(rural) %>% unique())

```

_(Sidenote: hey we repeated ourselves a lot there -- maybe we should write a function that pulls out a vector of unique values for a given variable? We'll get to that later.)_

# Creating new variables

Cool. Looking at `institution_unique` we see `r length(institution_unique)` unique values. But we don't need this level of detail. Instead, we can group them into useful categories: `school`, `vet`, `university` and `other/na`. First, define a vector that contains all the detailed `institution_unique` for each group. Create a vector using the `c` function (i.e. combine).

```{r institution unique}

university <- c("University or other Tertiary Institution")

vet <- c("Technical or Further Educational Institution (including TAFE Colleges)")

```

Writing out the unique values can be tedious, so we can just refer to elements of the `institution_unique` vector directly:

```{r institution unique2}
(school <- institution_unique[1:7])

(other_na <- institution_unique[10:12])
```

With our groups defined, we can create a VET dummy variable in the `vet_participation` dataset using `mutate`. Note that `mutate` creates or replaces/updates a variable, so `...mutate(income = income * 2)` will 'update' the income variable to be double. 

We will also employ the function `%in%` which means 'is contained within' and returns a logical. In this example: for each row, if the `institution` variable is contained within the `vet` vector we defined before, the `is_vet` variable will be `TRUE`; otherwise it will be `FALSE`.

```{r mutate}

vet_participation <- vet_participation %>% 
                     mutate(is_vet = institution %in% vet)

```

We also want to add a variable `inst_group` which takes the value of `"vet"`, `"university"`, `"school"` or `"other"`. One way to do this would be nested `if_else` functions, like:

```{r nested, eval = FALSE}

vet_participation <- vet_participation %>% 
                     mutate(inst_group = 
                              if_else(inst_group %in% school, "school",
                                      if_else(inst_group %in% vet, "vet",
                                              if_else.......))) etc

```

Luckily, there is a `case_when` function that will save us from coding as if we're using Excel. The `case_when` function works like this and is a _delight_ to read:

```{r mutate2}

vet_participation <- vet_participation %>% 
                     mutate(inst_group = case_when(
                       institution %in% school     ~ "school",
                       institution %in% vet        ~ "vet",
                       institution %in% university ~ "university",
                       institution %in% other_na   ~ "other")
                     )

head(vet_participation)
                       
```

# Summarising data

Wonderful. Now we have a question: how many young people (15-24yo) are in each broad institution group? We have a bunch of variables we don't need here: `sex`, `institution`, `age`, `irsad_dec`, `rural` and, now, `is_vet`. We can summarise the dataset to answer this question. The `summarise` function collapses a dataset into a single row and returns names summary statistics. For example:

```{r summarise}

vet_participation %>% 
  summarise(sum_n = sum(n),
            count_rows = n(),
            mean_n = mean(n),
            you_can_name_it_whatever_you_want = median(n))

```

That returned four statistics---a count (using `n()`), the `sum`, the `mean` and the `median`---for the dataset. Kind of useful, but far more powerful when combined with `group_by`. The `group_by` variable creates (in the backround) separate datasets for each unique group. The `summarise` function will then return the statistics for each unique group.

Our question is about `inst_group`, so we group by those variables before summarising:

```{r summarise2}

inst_young_sum <- vet_participation %>% 
  filter(age == "15-19 years" | age == "20-24 years") %>%
  group_by(inst_group) %>% 
  summarise(sum_n = sum(n),
            count_rows = n(),
            mean_n = mean(n),
            median_n = median(n))

inst_young_sum

```


Beaut. 

# Creating visuals

There's too many unique groups in `inst_young_sum` now to quickly evaluate. Let's ~data viz~ it using `ggplot`. `ggplot` is based on the idea that most visualisations can be created using data, aesthetics and geoms. I'll jump right in here, but [Chapter 3 of Hadley Wickham's _R for Data Science_](https://r4ds.had.co.nz/data-visualisation.html) explains it all really well. 

So: 

* data: we'll use our summary dataset `age_inst`. 
* aesthetics: we want to plot the total number of people in each institutition group by age. Our `y` variable is `sum_n`; our `x` variable is `inst_group`. 
* geom: let's plot a bar chart using `geom_bar`. Note that we have calculated our statistic `sum_n` already. So we'll need to tell `geom_bar` that using the argument `stat = "identity"` (aka "just plot the number and don't do anything else to it").

This all looks like:

```{r ggplot}

inst_young_sum %>% 
  ggplot(aes(x = inst_group,
             y = sum_n)) +
  geom_bar(stat = "identity")

```


Nice. But it's all a bit **bland**. Let's liven it up with some $\color{red}{\text{COLOUR}}$. 

We can map `inst_group` to the `colour` aesthetic (note the difference between `colour` and `fill`). **ALSO** note that because Hadley is from NZ, we're allowed to spell colour correctly (...`color` also works).

```{r ggplot colour}

# 1 
inst_young_sum %>% 
  ggplot(aes(x = inst_group,
             y = sum_n,
             colour = inst_group)) +
  geom_bar(stat = "identity")

# 2
inst_young_sum %>% 
  ggplot(aes(x = inst_group,
             y = sum_n,
             fill = inst_group)) +
  geom_bar(stat = "identity")
```

Above we have 'mapped' colour to a variable, so it will change according to the variable. We can alternatively just set a colour for the `geom` by using `fill` or `colour` _outside of the `aes` function_:

```{r ggplot colour2}
inst_young_sum %>% 
  ggplot(aes(x = inst_group,
             y = sum_n)) +
  geom_bar(stat = "identity",
           fill = "red")

```

Woah that red is gross. And the order of our `x`-axis variables are all out-of-whack. `ggplot` has been supplied a set of `character` values in our `inst_group` variable that it has ordered alphabetically. We could `reorder` it to go from lowest `sum_n` to highest:

```{r ggplot order}

inst_young_sum %>% 
  ggplot(aes(x = reorder(inst_group, sum_n),
             y = sum_n,
             fill = inst_group)) +
  geom_bar(stat = "identity")
```

That has reordered things. The scientific notation is a bit annoying, and we don't like the grey background. We can change the default settings:

```{r cruft}
# Setting the theme
theme_set(theme_minimal())

# Setting the limit for scientific notation
options(scipen = 1000000)
```


Now, we can adjust the labels of the chart with `labs`:

```{r ggplot labs}
inst_young_sum %>% 
  ggplot(aes(x = reorder(inst_group, sum_n),
             y = sum_n,
             fill = inst_group)) +
  geom_bar(stat = "identity") +
  labs(x = "Institution group",
       y = "Number of people",
       fill = "Institution group")
```

Nicer. We don't really need the legend though, so we can turn it off:

```{r ggplot labs2}
inst_young_sum %>% 
  ggplot(aes(x = reorder(inst_group, sum_n),
             y = sum_n,
             fill = inst_group)) +
  geom_bar(stat = "identity") +
  labs(x = "Institution group",
       y = "Number of people") +
  theme(legend.position = "off")
```

Sick. But our `inst_group` order still doesn't really make sense. We would actually like to specify the order ourselves so it runs: `school`, `vet`, `university`, `other`. To do this we need to use `factors`. 

# Factors

A factor is a special data type that is kind-of-like a character but with some sometimes-useful properties. They're designed to be used with categorical variables, like `inst_group`. If you want to get right into factors-world, check out the first few subsections of [Chapter 15 of R4DS](https://r4ds.had.co.nz/factors.html).

But, best to a quick example: we define a character vector of sizes.

* Looking at `size` shows the list of character elements. 
* We then define a hierarchy in `size_order`, and 
* use it to generate `size_factor` which contains the elements of `size` and the ability to order according to `levels = size_order`. Note the output of `size_factor`.
* What happened to our "HELLO" element? It wasn't part of the defined levels, so was wiped. This _can be useful_ if you are ensuring that your data fit within a set of values. But because the resulting value is `NA`, it _can also be annoying_. Just be wary.
* We can also call for the levels of `size_factor`.

```{r factors}

size <- c("big", "big", "largest", "big", "small", "small", "tiny", "medium", "small", "HELLO")

size

size_order <- c("tiny", "small", "medium", "big", "largest")

size_factor <- factor(size,
                      levels = size_order)


size_factor

levels(size_factor)

```


This comes in handy when we want to order unique elements of a vector. We can do the same thing for `inst_group`. Define the levels, then convert the `inst_group` variable to a factor with those levels:

```{r factors2}

inst_group_levels <- c("school", "vet",
                       "university", "other")

inst_young_sum <- inst_young_sum %>% 
  mutate(inst_group = factor(inst_group, 
                             levels = inst_group_levels))

```

Now we can plot with some sort of control over the order:

```{r factors3}
inst_young_sum %>% 
  ggplot(aes(x = inst_group,
             y = sum_n,
             fill = inst_group)) +
  geom_bar(stat = "identity")
```



# Recreating charts

Now that you know _everything_ there is to know about `R` and the `tidyverse`, you will be able to recreate the following charts.

## Recreate 1

Create this dataset, where `n` is the total number of people in each group.

```{r recreate1, echo = FALSE}

by_sex <-
vet_participation %>% 
        filter(age == "15-19 years" | age == "20-24 years") %>% 
        group_by(sex, age, inst_group) %>% 
        summarise(n = sum(n))

by_sex

```

## Recreate 2

Recreate the following charts (and feel free to improve on them if you'd like!).

### A
```{r recreate2a, echo = FALSE}

by_sex %>% 
  ggplot(aes(x = sex,
         y = n,
         fill = inst_group)) +
  geom_bar(stat = "identity")

```


### B
Keyword: `"dodge"`

```{r recreate2b, echo = FALSE}

by_sex %>% 
  group_by(sex, inst_group) %>% 
  summarise(n = sum(n)) %>% 
  ggplot(aes(x = sex,
         y = n,
         fill = inst_group)) +
  geom_bar(stat = "identity",
           position = "dodge") +
  labs(y = "Number of 15-24 year-olds",
       x = "",
       fill = "Institution")

```

### C

Keyword: `facet`

```{r recreate2c, echo = FALSE}

by_sex %>% 
  ggplot(aes(x = sex,
         y = n,
         fill = inst_group)) +
  geom_bar(stat = "identity",
           position = "dodge") +
  facet_grid(. ~ age)

```


### D

```{r recreate2d, echo = FALSE}

by_sex %>% 
  filter(inst_group != "other") %>% 
  ggplot(aes(x = sex,
         y = n,
         fill = inst_group)) +
  geom_bar(stat = "identity",
           position = "dodge") +
  facet_grid(. ~ age)

```


### E

```{r recreate2e, echo = FALSE}

by_sex %>% 
  filter(inst_group != "other") %>% 
  ggplot(aes(x = age,
         y = n,
         fill = inst_group)) +
  geom_bar(stat = "identity",
           position = "dodge") +
  facet_grid(. ~ sex)

```


## Recreate 3

### A
Create this dataset:

Keywords: `factor`, `parse_number`
(Note: regular expression can be used here if you're familiar!)

```{r recreate3a, echo = FALSE}

by_irsad <-
vet_participation %>% 
        filter(age == "15-19 years" | age == "20-24 years",
               inst_group == "vet" | inst_group == "university") %>% 
        mutate(irsad_dec_num = parse_number(irsad_dec)) %>% 
        group_by(irsad_dec_num, sex, age, inst_group) %>% 
        summarise(n = sum(n))

by_irsad

```

### B

Keyword: `"fill"`

```{r recreate3b, echo = FALSE}
by_irsad %>% 
  filter(age == "20-24 years",
         !is.na(irsad_dec_num)) %>% 
  ggplot(aes(x = sex,
             y = n,
             fill = inst_group)) +
  geom_bar(stat = "identity", position = "fill") +
  facet_grid(. ~ irsad_dec_num) +
  theme(axis.text.x = element_text(angle = 90)) +
  labs(subtitle = "VET/University split for 20-24 year-olds, by IRSAD SES decile",
       caption = "",
       fill = "Studying at:",
       y = "Proportion of group",
       x = "")



```

### C

Keyword: `alpha`

```{r recreate3c, echo = FALSE}
by_irsad %>% 
  ggplot(aes(x = age,
             y = n,
             fill = sex,
             alpha = age)) +
  geom_bar(stat = "identity", position = "dodge") +
  facet_grid(inst_group ~ irsad_dec_num,
             scales = "free") +
  scale_alpha_discrete(range = c(.4, 1)) +
  theme(axis.text.x = element_text(angle = 90)) +
  labs(subtitle = "Number young people by study type and IRSAD SES decile",
       caption = "")
  
```


<!--

# Functions

```{r functions}
getUnique <- function(x) vet_participation %>% select(!!x) %>% unique()

getUnique("age")

```



-->








